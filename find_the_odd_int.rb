# Given an array, find the int that appears an odd number of times.
# There will always be only one integer that appears an odd number of times.


def find_it(seq)
  seq.find { |n| seq.count(n).odd? }   # аналог метода find метод detect
end
# find_it(array=[20,1,-1,2,-2,3,3,5,5,1,2,4,20,4,-1,-2,5])


# def find_it(seq)
#   seq.reduce(:^)
# end
# find_it(array=[20,1,-1,2,-2,3,3,5,5,1,2,4,20,4,-1,-2,5])


# find/ detect ==> Передаёт в указанный блок каждый элемент коллекции enum. Возвращает первый
# элемент enum, для которого результат выполнения block не является false.
# Если не найдено ни одного соответствия, возвращается значение
# параметра ifnone (если определён) либо nil

# count ==> Без аргументов возвращает количество элементов массива. Если задан аргумент,
# считает количество элементов для которых блок возвращает true.
# считает количество элементов которые равны obj через ==. Если передан блок,
# odd? - не четное
# even? - четное

# reduce или inject (также известный как foldLeft в других языках как OCaml или Scala)
# это метод который обрабатывает элементы enum применяя к ним блок,
# принимающий два параметра - аккумулятор (memo) и обрабатываемый элемент.
# На каждом шаге аккумулятору memo присваивается значение, возвращенное блоком.
# Первая форма позволяет присвоить аккумулятору некоторое исходное значение.
# Вторая форма в качестве исходного значения аккумулятора использует первый
# элемент коллекции (пропуская этот элемент при проходе).
# Комбинирует все элементы в enum, применяя бинарную операцию, переданную в виде
# блока или символа в метод.
# Если явно не указано начальное значение для memo, то первый элемент коллекции
# используется в качестве начального значения memo.
